This solution shows how to consume an EF6 library (written in .Net Framework 4.7.2) from newer .Net Core projects.

Project <b>OldEF6Library</b> is the original Entity Framework 6 project that we want to reuse in our .Net core projects. The EF project points to a database which contains just one sample table: "Users", which can be recreated like this:
    Create table Users ([Id] int primary key, [Name] varchar (200)). 
    
This library uses the DB first approach and generates an EDMX model.

Project <b>CoreConsoleApp</b> is a .Net core 3.1 console application. It consumes the OldEF6Library. 
To configure the connection string that the library will use, we insert it in an App.config file of the CoreConsoleApp project. The "Old" library will use this file to configure the EF source. 

Project <b>CoreWebApp</b> in a .Net Core 3.1 MVC web application. As with the CoreConsolApp project, the EF configuration strings are in a file called App.config. 

Project <b>CoreFunction</b> is a .Net core 3.1 Azure function project, which you can run locally or deploy to Azure. Differently from the other two projects, the original EF library  needs a small refactoring to allow the function to use it. This is because the version v2 and v3 of Azure functions don't support the ConfigurationManager API. This statement generates an exception as it uses the ConfigurationManager behind the curtains and it cannot read the UserEntities entry in a configuration file:

    public UserEntities():base("name=UserEntities")
        {
        } // this won't work.

So, it is necessary to inject a connection string from the CoreFunction assembly to the old library. An additional constructor is then necessary to allow the client to inject a connection string in the class .Context.cs (generated by EF in the case of database - first EDMX):

     public UserEntities(string connectionString)
        : base(connectionString)
        {
        }
        
Unfortunately, the class where we need to create a new constructor is generated by a tool and could be overwritten.
In order to configure the connection string in the .Net core function (client), we can use environment variables (corresponding to app settings in Azure). 

Locally
gih

Azure


In the client project, these variables are read with the this instruction:

     OldEF6Class.ConnectionString = Environment.GetEnvironmentVariable("UserEntitiesConnectionString");






